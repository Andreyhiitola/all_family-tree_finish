class FamilyTreeCore {
  constructor(people) { 
    this.setPeople(people || []) 
  }

  setPeople(people) {
    this.people = people || []
    console.log('üîÑ FamilyTree: –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—è', this.people.length, '—á–µ–ª–æ–≤–µ–∫')
    
    this.byId = new Map()
    this.people.forEach(p => this.byId.set(p.id, p))
    
    this.childrenByParentId = new Map()

    this.people.forEach(child => {
      const parentIds = [child.fatherId, child.motherId].filter(pid => pid)

      parentIds.forEach(parentId => {
        if (this.byId.has(parentId)) {
            if (!this.childrenByParentId.has(parentId)) {
                this.childrenByParentId.set(parentId, [])
            }
            this.childrenByParentId.get(parentId).push(child)
        }
      })
    })
    
    console.log('üë®‚Äçüë©‚Äçüëß‚Äçüë¶ –ò–Ω–¥–µ–∫—Å —Å–≤—è–∑–µ–π –ø–æ—Å—Ç—Ä–æ–µ–Ω. –†–æ–¥–∏—Ç–µ–ª–µ–π —Å –¥–µ—Ç—å–º–∏:', this.childrenByParentId.size)
  }

  getPersonById(id) { 
    return this.byId.get(id) 
  }

  getChildrenOf(id) { 
    return this.childrenByParentId.get(id) || []
  }

  // –ü–æ–ª—É—á–∞–µ—Ç –¥–µ—Ç–µ–π –ø–∞—Ä—ã (–æ–±—â–∏—Ö –¥–ª—è –æ–±–æ–∏—Ö —Å—É–ø—Ä—É–≥–æ–≤)
  getChildrenOfCouple(person1Id, person2Id) {
    const children1 = this.getChildrenOf(person1Id)
    const children2 = person2Id ? this.getChildrenOf(person2Id) : []
    
    // –û–±—ä–µ–¥–∏–Ω—è–µ–º –¥–µ—Ç–µ–π (—É–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã)
    const allChildren = [...children1]
    children2.forEach(child => {
      if (!allChildren.find(c => c.id === child.id)) {
        allChildren.push(child)
      }
    })
    
    return allChildren
  }


  // –ù–∞–π—Ç–∏ –≤—Å–µ—Ö —Å—É–ø—Ä—É–≥–æ–≤ —á–µ–ª–æ–≤–µ–∫–∞ (—Ç–µ–∫—É—â–∏—Ö –∏ –±—ã–≤—à–∏—Ö —á–µ—Ä–µ–∑ –¥–µ—Ç–µ–π)
  getAllSpouses(personId) {
    const spouses = [];
    const person = this.getPersonById(personId);
    
    // –¢–µ–∫—É—â–∏–π —Å—É–ø—Ä—É–≥ –∏–∑ spouseId
    if (person?.spouseId) {
      spouses.push(this.getPersonById(person.spouseId));
    }
    
    // –ë—ã–≤—à–∏–µ —Å—É–ø—Ä—É–≥–∏ —á–µ—Ä–µ–∑ –¥–µ—Ç–µ–π
    const children = this.getChildrenOf(personId);
    children.forEach(child => {
      const otherId = person.gender === "M" ? child.motherId : child.fatherId;
      if (otherId && otherId !== person.spouseId) {
        const other = this.getPersonById(otherId);
        if (other && !spouses.find(s => s.id === other.id)) {
          spouses.push(other);
        }
      }
    });
    
    return spouses.filter(s => s);
  }

  // –ù–∞–π—Ç–∏ –≤—Å–µ—Ö —Å—É–ø—Ä—É–≥–æ–≤ —á–µ–ª–æ–≤–µ–∫–∞ (—Ç–µ–∫—É—â–∏—Ö –∏ –±—ã–≤—à–∏—Ö —á–µ—Ä–µ–∑ –¥–µ—Ç–µ–π)
  getAllSpouses(personId) {
    const spouses = [];
    const person = this.getPersonById(personId);
    
    // –¢–µ–∫—É—â–∏–π —Å—É–ø—Ä—É–≥ –∏–∑ spouseId
    if (person?.spouseId) {
      spouses.push(this.getPersonById(person.spouseId));
    }
    
    // –ë—ã–≤—à–∏–µ —Å—É–ø—Ä—É–≥–∏ —á–µ—Ä–µ–∑ –¥–µ—Ç–µ–π
    const children = this.getChildrenOf(personId);
    children.forEach(child => {
      const otherId = person.gender === "M" ? child.motherId : child.fatherId;
      if (otherId && otherId !== person.spouseId) {
        const other = this.getPersonById(otherId);
        if (other && !spouses.find(s => s.id === other.id)) {
          spouses.push(other);
        }
      }
    });
    
    return spouses.filter(s => s);
  }
  buildDescendantsHierarchy(rootId) {
    const root = this.getPersonById(rootId)
    if (!root) {
      console.warn('‚ùå –ö–æ—Ä–µ–Ω—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∏–Ω–¥–µ–∫—Å–µ:', rootId)
      return null
    }

    console.log(`üå≥ –°—Ç—Ä–æ–∏–º —Å–µ–º–µ–π–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –æ—Ç: ${root.name} ${root.surname} (ID: ${root.id})`)

    const processedPeople = new Set()

    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è —É–∑–ª–∞ —Å —Å—É–ø—Ä—É–≥–æ–º
    const buildFamilyNode = (person, depth) => {
      if (depth > 50 || processedPeople.has(person.id)) {
        return null
      }

      processedPeople.add(person.id)

      const spouse = person.spouseId ? this.getPersonById(person.spouseId) : null
      
      if (spouse) {
        processedPeople.add(spouse.id)
      }

      // –°–æ–∑–¥–∞–µ–º —É–∑–µ–ª —Å–µ–º—å–∏
      const familyNode = {
        type: 'family',
        id: `family-${person.id}`,
        person1: {
          id: person.id,
          name: person.name,
          surname: person.surname,
          gender: person.gender
        },
        person2: spouse ? {
          id: spouse.id,
          name: spouse.name,
          surname: spouse.surname,
          gender: spouse.gender
        } : null,
        children: []
      }

      // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –¥–µ—Ç–µ–π –ø–∞—Ä—ã
      const children = this.getChildrenOfCouple(person.id, spouse?.id)
      
      children.sort((a, b) => (a.birthDate || '9999') > (b.birthDate || '9999') ? 1 : -1)

      children.forEach(child => {
        const childNode = buildFamilyNode(child, depth + 1)
        if (childNode) {
          familyNode.children.push(childNode)
        }
      })

      if (familyNode.children.length === 0) {
        delete familyNode.children
      }

      return familyNode
    }

    const treeData = buildFamilyNode(root, 0)
    return d3.hierarchy(treeData, d => d.children || [])
  }

  getSpousePairs() {
    const pairs = []
    const seen = new Set()
    
    this.people.forEach(person => {
      if (person.spouseId && !seen.has(person.id)) {
        const spouse = this.getPersonById(person.spouseId)
        
        if (spouse) {
          pairs.push({
            person1: person,
            person2: spouse
          })
          
          seen.add(person.id)
          seen.add(spouse.id)
        }
      }
    })
    
    console.log('üíë –ù–∞–π–¥–µ–Ω–æ —Å—É–ø—Ä—É–∂–µ—Å–∫–∏—Ö –ø–∞—Ä:', pairs.length)
    return pairs
  }
}

window.FamilyTreeCore = FamilyTreeCore
